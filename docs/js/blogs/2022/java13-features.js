(function(n){function e(e){for(var a,i,l=e[0],s=e[1],c=e[2],u=0,d=[];u<l.length;u++)i=l[u],Object.prototype.hasOwnProperty.call(o,i)&&o[i]&&d.push(o[i][0]),o[i]=0;for(a in s)Object.prototype.hasOwnProperty.call(s,a)&&(n[a]=s[a]);S&&S(e);while(d.length)d.shift()();return r.push.apply(r,c||[]),t()}function t(){for(var n,e=0;e<r.length;e++){for(var t=r[e],a=!0,l=1;l<t.length;l++){var s=t[l];0!==o[s]&&(a=!1)}a&&(r.splice(e--,1),n=i(i.s=t[0]))}return n}var a={},o={"blogs/2022/java13-features":0},r=[];function i(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.m=n,i.c=a,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"===typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)i.d(t,a,function(e){return n[e]}.bind(null,a));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n["default"]}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/";var l=window["webpackJsonp"]=window["webpackJsonp"]||[],s=l.push.bind(l);l.push=e,l=l.slice();for(var c=0;c<l.length;c++)e(l[c]);var S=s;r.push([15,"chunk-vendors","chunk-common"]),t()})({15:function(n,e,t){n.exports=t("9dd0")},"9dd0":function(n,e,t){"use strict";t.r(e);var a=t("f2bf"),o='### 添加三个 FileSystems.newFileSystem 重载方法\n\njava.nio.file.FileSystems 添加了三个新方法，使可以更方便的使用 FileSystem.\n\n- newFileSystem(Path)\n- newFileSystem(Path, Map<String, ?>)\n- newFileSystem(Path, Map<String, ?>, ClassLoader) \n\n### java.nio.ByteBuffer 新增加批量的 get/put 方法\n\n新增加方法 get(byte[] dst) 方法可将 ByteBuffer 的内容传输到指定的数组中，方法 put(byte[] src) 用于将指定字节数组中的内容全部传输到 ByteBuffer 中。\n\n### 支持 Unicode 12.1\n\n下面的相关 API 做了对 unicode 12.1 版本的支持：\n\n- java.lang.Character \n- java.text.Bidi 和 java.text.Normalizer \n- 包 java.util.regex\n\n### ZGC 归还无用内存\n\n在之前的 jdk12 中已经做了对归还无用内存的增强。新增参数 -XX:ZUncommitDelay=<seconds>（默认300秒）用于指定内存有多长时间未使用才能被归还。\n\n### 新增 -XXSoftMaxHeapSize 参数\n\n添加了新的命令行参数 -XX:SoftMaxHeapSize=<bytes>，只对 ZGC 有用。如果设置了这个参数，回收器将努力不让增长的内存超出设定值，除非是为了不让内存溢出必须要增长更多的内存。这个参数可以在运行时设置，可以通过 HotSpot MXBean 或 jcmd 来更改。\n\n### ZGC 最大堆大小增加到 16TB\n\nZGC 支持的最大内存从 4TB 提升到了 16TB。\n\n### 动态 CDS 归档\n\n扩展 AppCDS（application class-data sharing 应用类数据共享），允许在程序退出时动态存档类数据（class-data）。\nJDK 5 中引入了 CDS （Class-Data Sharing）技术，允许把一组类预处理为共享归档文件，在启动时可以被直接映射到内存，从而减少启动时间。当有多个 JVM 进程共享相同的文件时，也可以减少动态内存占用。但是 CDS 只允许 bootstrap 类加载器加载存档文件，AppCDS 扩展了 CDS，允许内建的类加载器和用户自定义的类加载器加载存档文件。动态 CDS 归档（Dynamic CDS Archives）对 AppCDS  又进行了扩展，允许在程序结束时动态的存档类信息。\n\n动态 CDS 归档相比 AppCDS 简化了流程，提升了易用性，AppCDS 需要有三个步骤：\n\n1. 执行一到多次的试运行，来创建 class 列表\n2. 通过创建的 class 列表来导出归档文件\n3. 使用归档文件运行程序\n\n```bash\n# 创建 class 列表\njava -Xshare:off -XX:+UseAppCDS -XX:DumpLoadedClassList=hello.lst -cp hello.jar HelloWorld\n# 使用创建的 class 列表导出归档文件\njava -Xshare:dump -XX:+UseAppCDS -XX:SharedClassListFile=hello.lst \\\n    -XX:SharedArchiveFile=hello.jsa -cp hello.jar\n# 使用归档文件来运行程序\njava -Xshare:on -XX:+UseAppCDS -XX:SharedArchiveFile=hello.jsa \\\n    -cp hello.jar HelloWorld\n```\n\n而动态 CDS 归档相较而言则省略了第一个步骤，可以设置在程序退出时自动生成归档文件，下次使用归档文件来运行程序。\n\n```bash\n# 设置程序在退出时生成归档文件\njava -XX:ArchiveClassesAtExit=hello.jsa -cp hello.jar Hello\n# 使用归档文件来运行程序\njava -XX:SharedArchiveFile=hello.jsa -cp hello.jar Hello\n```\n\n### CRL 超时时间可配置\n\n通过系统属性 com.sun.security.crl.readtimeout 可以设置 CRL （Certificate Revocation List）检索的最大时间，单位秒，未设置默认15秒。\n\n### 新的命令 keytool -showinfo -tls 用于显示 TLS 配置信息\n\n添加了新命令 keytool -showinfo -tls 用于显示 TLS 配置。\n\n```\n$ keytool -showinfo -tls\n\nEnabled Protocols\n-----------------\nTLSv1.3\nTLSv1.2\n\nEnabled Cipher Suites\n---------------------\nTLS_AES_256_GCM_SHA384\nTLS_AES_128_GCM_SHA256\nTLS_CHACHA20_POLY1305_SHA256\n....\n```\n\n### 支持 windows 系统 CNG\n\nSunMSCAPI 支持了从 CNG （Cryptography Next Generation）格式中读取私钥。SunMSCAPI 是一种可通过 JCA/JCE 接口直接使用 windows 系统密钥库的技术，前面整理 java 11 更新内容时有介绍过。这个功能是不能跨平台的，一般的程序开发很少用。\n\n### SunPKCS11 支持 PKCS#11 v2.40\n\nSunPKCS11 做了更新，支持了 PKCS#11 v2.40，这个版本支持了更多的算法。\n\n### 在 TLS 中支持 X25519 和 X448\n\nx25519 和 x448 现在可用于 TLS 版本 1.0 到 1.3 中的 JSSE 密钥协商。\n\n### JSSE 无服务器状态恢复会话\n\n该特性允许 JSSE 的服务器端无状态运行，TLS 服务器以加密会话ticket的形式向支持无状态的客户端发送内部会话信息，该会话ticket在 TLS 握手期间提供给服务器以恢复会话。这应该会提升 TLS 服务器在高负载下的性能和内存使用率，因为会话缓存很少使用。\n\n### 允许限制 SASL 机制\n\n通过安全属性 jdk.sasl.disabledMechanisms 可以禁用 SASL 机制。 SASL全称Simple Authentication and Security Layer，是一种用来扩充C/S模式验证能力的机制。这个机制其实很弱，所以支持限制使用能更方便些。\n\n### XML 1.1 URI 添加新字符串常量\n\n新的常量 INCLUSIVE_11 和 INCLUSIVE_11_WITH_COMMENTS添加到了javax.xml.crypto.dsig.CanonicalizationMethod 中。\n\n```java\n/**\n  * The <a href="http://www.w3.org/TR/2001/REC-xml-c14n-20010315">Canonical\n  * XML (without comments)</a> canonicalization method algorithm URI.\n  */\nstatic final String INCLUSIVE =\n        "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";\n\n/**\n  * The\n  * <a href="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">\n  * Canonical XML with comments</a> canonicalization method algorithm URI.\n  */\nstatic final String INCLUSIVE_WITH_COMMENTS =\n        "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments";\n```\n\n### xmldsig 添加了 KeyValueEC 类型\n\n支持了 [W3C Recommendation for XML-Signature Syntax and Processing](https://www.w3.org/TR/xmldsig-core/#sec-ECKeyValue) 中的 ECKeyValue 类型，接口 javax.xml.crypto.dsig.keyinfo.KeyValue 中添加了常量 EC_TYPE。\n\n```java\n/**\n * URI identifying the EC KeyValue KeyInfo type:\n * http://www.w3.org/2009/xmldsig11#ECKeyValue. This can be specified as\n * the value of the <code>type</code> parameter of the\n * {@link RetrievalMethod} class to describe a remote\n * <code>ECKeyValue</code> structure.\n */\nstatic final String EC_TYPE = "http://www.w3.org/2009/xmldsig11#ECKeyValue";\n```\n\nEC（Elliptic Curve） 公钥 xml 数字签名语法示例：\n\n```xml\n<ECKeyValue xmlns="http://www.w3.org/2009/xmldsig11#">\n  <NamedCurve URI="urn:oid:1.2.840.10045.3.1.7" />\n  <PublicKey>\n    vWccUP6Jp3pcaMCGIcAh3YOev4gaa2ukOANC7Ufg\n    Cf8KDO7AtTOsGJK7/TA8IC3vZoCy9I5oPjRhyTBulBnj7Y\n  </PublicKey>\n</ECKeyValue>\n```\n\n### windows 平台上添加一个默认的本地 GSS-API 库\n\nwindows 版本的 jdk 添加了一个本地的 GSS-API 库，该库仅仅是客户端，并使用默认凭据。将系统属性 sun.security.jgss.native 设置为 true ，将会加载该库，也可以通过 sun.security.jgss.lib 来加载第三方本地库。\n\nGSS-API 是一个以通用方式为调用方提供安全服务的框架。许多底层机制和技术（如 Kerberos v5 或公钥技术）都支持 GSS-API 框架。\n\nGSS-API 参考资料:\n\n- [Generic Security Service Application Program Interface](ftp://ftp.isi.edu/in-notes/rfc2743.txt)\n- [Generic Security Service API Version 2: C-Bindings](ftp://ftp.isi.edu/in-notes/rfc2744.txt)\n\n### 支持 Kerberos Cross-Realm Referrals (RFC 6806)\n\nKerberos 客户端增强，支持主体名称规范化和跨域引用（Principal Name Canonicalization and Cross-Realm Referrals），详细可查看 RFC 6806。\n\n### switch 表达式增强\n\n之前 jdk 12 中 引入了 case ... -> 语法，可在 case 后跟上表达式，不会出现下落的情况，不需要写 break。现在不管表达式还是语句都可以支持了，方便了不少。\n\n```java\nswitch (flag) {\n   case 1 -> System.out.println("1");\n   // 表达式\n   case 3 -> System.out.println("1");\n   case 4 -> {\n　　　// 语句\n      String str = "4";\n      System.out.println(str);\n   }\n}\n```\n\n新特性也是为未来在 switch 中支持模式匹配做准备，模式匹配示例：\n\n```java\nstatic String formatterPatternSwitch(Object o) {\n    return switch (o) {\n        case Integer i -> String.format("int %d", i);\n        case Long l    -> String.format("long %d", l);\n        case Double d  -> String.format("double %f", d);\n        case String s  -> String.format("String %s", s);\n        default        -> o.toString();\n    };\n}\n```\n\n当然，模式匹配目前为止还没有支持，我使用的 jdk17 仍然不能使用这个语法。\n\n### 文本块\n\n支持多行字符串字面量，不需要拼接和写各种转义，可读性更好。\n\n之前版本拼接字符串：\n\n```java\nString html = "<html>\\n" +\n              "    <body>\\n" +\n              "        <p>Hello, world</p>\\n" +\n              "    </body>\\n" +\n              "</html>\\n";\n```\n\n使用文本块：\n\n```java\nString html = """\n              <html>\n                  <body>\n                      <p>Hello, world</p>\n                  </body>\n              </html>\n              """;\n```\n\n新语法确实方便了不少，但是没有支持插件表达式，如果能像 es6 的模板字符串一样就好了。在官方的文档中，对于这种动态拼接的需求，给的方案是使用字符串自带的替换或格式化。\n\n```java\nString code = """\n              public void print($type o) {\n                  System.out.println(Objects.toString(o));\n              }\n              """.replace("$type", type);\nString source = """\n                public void print(%s object) {\n                    System.out.println(Objects.toString(object));\n                }\n                """.formatted(type);\n```\n\n### 新增创建支持命名空间的 DOM 和 SAX 工厂的方法\n\n新增加了三个方法：\n\n- newDefaultNSInstance()\n- newNSInstance()\n- newNSInstance(String factoryClassName, ClassLoader classLoader) \n\n使用上面这几个方法，通过工厂创建的解析器是默认支持命名空间的。\n\n```java\nDocumentBuilder db = DocumentBuilderFactory.newDefaultNSInstance().newDocumentBuilder();\n```\n\n相当于：\n\n```java\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newDefaultInstance(); \ndbf.setNamespaceAware(true); \nDocumentBuilder db = dbf.newDocumentBuilder();\n```\n\n### javadoc 删除一些旧的特性\n\n不再支持使用 html4 生成 api 文档，jdk9 开始就支持了 html5，生成 api 文档时要保证使用的 html 标签必须能完全符合 html5。\n\n不再支持一些老的 javadoc API，包含 com.sun.javadoc , 旧的文档部件 (com.sun.tools.doclets.standard), 和旧的入口 (com.sun.tools.javadoc.Start)等。 \n\n不再支持使用 HTML frame 来生成文档。\n\n不再支持 --no-module-directories，此选项为 JDK 9 和 10 中的 javadoc 工具用于限制生成文档的目录结构，其中不同模块的文件未分组到单独的目录中\n\n### 其它被删除的功能特性\n\n- 删除系统属性 awt.toolkit\n- java.lang.Runtime 中删除traceInstructions(boolean)和traceMethodCalls(boolean) 两个方法，相关的功能可使用 JVMTI\n- 早于 jdk 1.4 版本的SocketImpl实现类被移除\n- 删除命令行参数 -XX+AggressiveOpts\n- SunJSSE 中删除了对RSA KeyFactory,RSA KeyPairGenerator,MD2withRSA,MD5withRSA, 和SHA1withRSA Signature的支持 \n- 证书 T-Systems Deutsche Telekom Root CA 2 已经过时了，被从 cacerts 密钥库中删除\n- 删除两个 DocuSign 根证书：certplusclass2primaryca、certplusclass3pprimaryca\n- 删除两个Comodo根证书：utnuserfirstclientauthemailca、utnuserfirsthardwareca\n- 内部包 com.sun.net.ssl 被删除\n- 实验性的 FIPS 140 兼容模式已从 SunJSSE 中删除\n\n### 被废弃的功能特性\n\n- 废弃并不再支持 mac os 平台上 swing 的 Motif Look and Feel，相关源码已经删除，使用 javax.swing.plaf.metal.MetalLookAndFeel 来替代 \n- 废弃 rmic，标记将来会被删除。rmic 工具用于创建支持 Java 远程方法调用 (RMI) 工具使用的 Java 远程方法协议 (JRMP) 的静态存根。\n- 废弃java 命令行参数 -Xverifynone 和 -noverify\n- javax.security.cert api 被废弃',r=t("f373");Object(a["c"])(Object(r["a"])(o)).mount("#app")}});