(function(e){function n(n){for(var o,l,s=n[0],c=n[1],i=n[2],p=0,h=[];p<s.length;p++)l=s[p],Object.prototype.hasOwnProperty.call(r,l)&&r[l]&&h.push(r[l][0]),r[l]=0;for(o in c)Object.prototype.hasOwnProperty.call(c,o)&&(e[o]=c[o]);u&&u(n);while(h.length)h.shift()();return a.push.apply(a,i||[]),t()}function t(){for(var e,n=0;n<a.length;n++){for(var t=a[n],o=!0,s=1;s<t.length;s++){var c=t[s];0!==r[c]&&(o=!1)}o&&(a.splice(n--,1),e=l(l.s=t[0]))}return e}var o={},r={"blogs/2022/java-bio-nio-aio":0},a=[];function l(n){if(o[n])return o[n].exports;var t=o[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,l),t.l=!0,t.exports}l.m=e,l.c=o,l.d=function(e,n,t){l.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},l.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},l.t=function(e,n){if(1&n&&(e=l(e)),8&n)return e;if(4&n&&"object"===typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(l.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)l.d(t,o,function(n){return e[n]}.bind(null,o));return t},l.n=function(e){var n=e&&e.__esModule?function(){return e["default"]}:function(){return e};return l.d(n,"a",n),n},l.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},l.p="/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],c=s.push.bind(s);s.push=n,s=s.slice();for(var i=0;i<s.length;i++)n(s[i]);var u=c;a.push([10,"chunk-vendors","chunk-common"]),t()})({10:function(e,n,t){e.exports=t("b085")},b085:function(e,n,t){"use strict";t.r(n);var o=t("f2bf"),r='如果你经常看编程方面的文章或视频，常常会收到关于同步和阻塞相关的推送或推荐，解释四种组合。\n很长一段时间我也搞不明白这些概念，带着这样的疑问，查阅了很多资料。网上有很多文章都是各种打比方，\n像排队买饭或是打电话预约等之类的，看了之后我更感觉更懵了。下面来说说我的理解，在这里主要还是解释概念，\n然后上代码演示，我相信看代码会比打比方能有更直观的感受。\n\n### 同步（synchronous）和异步（asynchronous）\n\n同步和异步其实就两种不同的编程风格，同步表示必须要等一个步骤执行完成有结果了，才可以执行后面的步骤。\n\n```js\n// 同步代码演示\nconst result1 = step1()\n// step1 是同步的，step2 必须要等等 step1 执行完成才可以执行\nstep2()"\n```\n\n同步其实也意味着是**阻塞**的，上面的例子中 step1 执行的时候会阻塞当前线程，如果 step1 执行时间太长，step2 也只能等，必须要顺序执行，我们可以把这个等的过程就是阻塞。\n\n而异步是不需要等待的，一个步骤还没有结果，下一个步骤就可以立即执行，不必按顺序，可以通过回调在未来处理结果。同步的顺序执行更符合人类直觉，而异步常常会很复杂，如果异步需要顺序，每个步骤都需要在上一个步骤的回调中执行，就会产生回调地狱。\n\n```js\n// 异步代码演示，step1 不会立即返回结果，在 callback 中可以处理 step1 的结果\nstep1Async(callback)\n// step1 调用后，step2 立刻执行，不需要等待 step1 执行完\nstep2()"\n```\n\n关于同步和异步就说这么多，我觉得还是很好理解的，一般也不会在这里产生困惑。\n\n### BIO（blocking I/O）\n\nBIO 就是阻塞的 IO，相信大家都很熟悉，也非常容易理解。\n\n```java\nfinal FileInputStream fis = new FileInputStream("demo2.zip");\nfinal byte[] bytes = fis.readAllBytes();\nSystem.out.println("文件读取完毕：" + bytes.length + " 字节");\n```\n\n上面是 java.io 接口使用 BIO 模式读取文件内容的代码，不多赘述了，接着看 NIO。\n\n### NIO（New Input/Output）\n\n网上有很多文章解释 NIO 是 non-blocking io，这是错的，实际上 NIO 就是新的 io，下面是 Java 官方文档中的说明：\n\n> The Java NIO (New Input/Output) API defines buffers, which are containers for data, and other structures and mechanisms to support buffers.\n\nNIO 中大部分操作仍然是阻塞的，只有 SelectableChannel 支持多路复用，可以实现无阻塞。所以，NIO 大部分 API 也是 BIO 。\n\n> Multiplexed, non-blocking I/O: Multiplexing is the ability to process multiple I/O operationsin one channel. Selectable channels support this. A selectable channel can be put into blocking or non-blocking mode. In blocking mode, every I/O operation invoked upon the channel will block until it completes. In non-blocking mode, an I/O operation will never block and may transfer fewer bytes than were requested or possibly no bytes at all. See the SelectableChannel class.\n\n#### NIO 中的 BIO 例子，使用 channel 读取文件\n\n下面是一个简单的例子，使用 nio 读取文件内容，仍然是阻塞的。\n\n```java\nfinal Path path = Paths.get("demo2.zip");\nfinal FileChannel fc = FileChannel.open(path);\nfinal ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\nint length;\nlong totalBytes = 0L;\nwhile ((length = fc.read(byteBuffer)) != -1) {\n  totalBytes += length;\n  byteBuffer.clear();\n}\nSystem.out.println("文件的大小是 ：" + totalBytes + " 字节");\n```\n\n为了减少代码量，我省略了读取文件内容的过程，只统计了字节总数。我看到外网有些博客把这个读取文件例子说成是 synchronous non blocking，我认为是不对的。看了这段代码，相信你和我会是一样的感觉：这和同步阻塞有什么区别？其实这就是同步阻塞的。\n\n#### NIO 无阻塞（non blocking）例子\n\n下面是一个 Java 官方文档中给的例子，无阻塞时间服务，每当有客户端连接就向客户端打印当前的时间。我做了些精简，然后又加了一些中文注释。\n\n```java\n// Selector for incoming time requests\nSelector acceptSelector = SelectorProvider.provider().openSelector();\n// Create a new server socket and set to non blocking mode\n// ServerSocketChannel 实现了 SelectableChannel,支持无阻塞\nServerSocketChannel ssc = ServerSocketChannel.open();\n// 设置为无阻塞模式\nssc.configureBlocking(false);\n// Bind the server socket to the local host and port\nInetAddress lh = InetAddress.getLocalHost();\nInetSocketAddress isa = new InetSocketAddress(lh, port);\nssc.socket().bind(isa);\n\n// Register accepts on the server socket with the selector. This\n// step tells the selector that the socket wants to be put on the\n// ready list when accept operations occur, so allowing multiplexed\n// non-blocking I/O to take place.\n// 注册感兴趣的 key: OP_ACCEPT ，当 OP_ACCEPT 操作发生时，\n// 会在下次的 selection operation 中看到（下面的 acceptSelector.select() ）\nSelectionKey acceptKey = ssc.register(acceptSelector, SelectionKey.OP_ACCEPT);\nSystem.out.println(acceptKey);\n\n// Here\'s where everything happens. The select method will\n// return when any operations registered above have occurred, the\n// thread has been interrupted, etc.\n// select() 执行一个阻塞的 selection operation ，直到下面的其中一种情况发生：\n// 1. 至少有一个 channel 被选择\n// 2. 当前 selector 实例 的 wakeup 方法被调用\n// 3. 当前线程被中断\n// 这里 selector 会一直阻塞，直到 ssc （ServerSocketChannel）准备接受连接（前面注册了 OP_ACCEPT）\n// while 的条件是 acceptSelector.select() > 0，只要不发生 2 和 3 的情况，循环就会一直进行下去\nwhile (acceptSelector.select() > 0) {\n  // Someone is ready for I/O, get the ready keys\n  Set<SelectionKey> readyKeys = acceptSelector.selectedKeys();\n  Iterator<SelectionKey> i = readyKeys.iterator();\n  System.out.println("while2");\n  // Walk through the ready keys collection and process date requests.\n  while (i.hasNext()) {\n    SelectionKey sk = i.next();\n    i.remove();\n    // The key indexes into the selector so you\n    // can retrieve the socket that\'s ready for I/O\n    ServerSocketChannel nextReady = (ServerSocketChannel) sk.channel();\n    // Accept the date request and send back the date string\n    Socket s = nextReady.accept().socket();\n    // Write the current time to the socket\n    PrintWriter out = new PrintWriter(s.getOutputStream(), true);\n    Date now = new Date();\n    out.println(now);\n    out.close();\n  }\n}\n```\n\n上面就是一个同步无阻塞的例子，写的仍然是同步代码，我们能够明显感受到是通过 configureBlocking() 设置了无阻塞模式，然后就是代码比较复杂，有点绕（费脑）。\n**实际上这里的无阻塞指的是可以做到一个线程处理多个连接**\n，不必一个请求处理完才可以处理下一个请求，这样相比一个线程只能处理一个请求的模式，就不容易因为请求太多而造成阻塞，提升了吞吐量。或者可以认为无阻塞是请求无阻塞，这样可能更好理解，一般说到同步无阻塞都是说的连接处理，其它方面的例子我还没有见到。\n\n编写一个客户端程序来验证下，连接服务，打印接收到的内容，然后退出。\n\n```java\nfinal InetAddress lh = InetAddress.getLocalHost();\nfinal Socket socket = new Socket(lh.getHostAddress(), port);\nfinal InputStream in = socket.getInputStream();\nfinal byte[] bytes = in.readAllBytes();\nSystem.out.println(new String(bytes));"\n```\n\n上面的代码每次运行，都会打印出当前的时间。通过调试可以发现服务器端代码走到\nacceptSelector.select() 就会阻塞不再继续，每次客户端建立连接，acceptSelector.select()\n就会返回结果，进入循环中，处理完又继续阻塞等待。\n\n### AIO（asynchronous IO）\n\nJava 中的 AIO 实际上也属于 NIO ，在 java.nio 这个包下，使用上只是略有区别，创建异步的 channel 即可。\n\n```java\nfinal Path path = Paths.get("demo2.zip");\nfinal AsynchronousFileChannel fc = AsynchronousFileChannel.open(path);\nfinal ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\nlong totalBytes = 0L;\nlong offset = 0;\nwhile (true) {\n  final Future<Integer> future = fc.read(byteBuffer, offset);\n  // 读取返回的是一个异步结果，不会阻塞，下面的代码会立即执行，而不必等待\n  System.out.println("do something ... ");\n  // 调用 future 的 get() 等待异步完成返回结果，再继续后面的逻辑\n  int length = future.get();\n  if (length == -1) {\n    break;\n  }\n  offset += length;\n  totalBytes += length;\n  byteBuffer.clear();\n}\nSystem.out.println("文件的大小是 ：" + totalBytes + " 字节");\n```\n\n这段代码和前面的使用 channel 读取文件的例子作用是一样的，不同的是使用了\nAsynchronousFileChannel，读取内容返回的是 Future 对象来表示异步结果。代码中调用了 get()\n方法在当前线程等待异步操作完成返回结果，get() 是阻塞的，直到异步完成或发生异常，相当于 es6\n中的 await ，在 Java 中使用 Future 可以以同步的方式来写异步代码，避免写出非常复杂的回调。Future\n在安卓程序的开发中比较常用，由于安卓只允许在主线程中渲染 UI，所以可以将一些异步操作（http\n请求等）封装成 Future 对象返回，然后在主线程中等待所有的异步操作完成，拿到结果后再进行渲染。\n\n### 总结\n\n文章开头说了常常会有四种 IO 模式的区分的问题，有些面试题可能会问，但是本文的代码只演示了三种模式，\n实现是不存在异步阻塞模式的，只有三种模式，想想看，在异步中的代码不管是怎么写的，对于调用处来说都是无阻塞的。\n\n感谢你能看到这，写了这么多，希望能对你有用。',a=t("f373");Object(o["c"])(Object(a["a"])(r)).mount("#app")}});