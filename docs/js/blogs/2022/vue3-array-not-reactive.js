(function(e){function n(n){for(var r,i,o=n[0],l=n[1],u=n[2],d=0,p=[];d<o.length;d++)i=o[d],Object.prototype.hasOwnProperty.call(a,i)&&a[i]&&p.push(a[i][0]),a[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(e[r]=l[r]);c&&c(n);while(p.length)p.shift()();return s.push.apply(s,u||[]),t()}function t(){for(var e,n=0;n<s.length;n++){for(var t=s[n],r=!0,o=1;o<t.length;o++){var l=t[o];0!==a[l]&&(r=!1)}r&&(s.splice(n--,1),e=i(i.s=t[0]))}return e}var r={},a={"blogs/2022/vue3-array-not-reactive":0},s=[];function i(n){if(r[n])return r[n].exports;var t=r[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.m=e,i.c=r,i.d=function(e,n,t){i.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},i.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,n){if(1&n&&(e=i(e)),8&n)return e;if(4&n&&"object"===typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)i.d(t,r,function(n){return e[n]}.bind(null,r));return t},i.n=function(e){var n=e&&e.__esModule?function(){return e["default"]}:function(){return e};return i.d(n,"a",n),n},i.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},i.p="/";var o=window["webpackJsonp"]=window["webpackJsonp"]||[],l=o.push.bind(o);o.push=n,o=o.slice();for(var u=0;u<o.length;u++)n(o[u]);var c=l;s.push([11,"chunk-vendors","chunk-common"]),t()})({11:function(e,n,t){e.exports=t("b279")},b279:function(e,n,t){"use strict";t.r(n);var r=t("f2bf"),a='最近在编程时，遇到了 vue3 数组更新却没有响应的问题，解决后，决定把这次的问题总结下，记录下来。\n\n### 代码重现\n\n项目的代码太复杂了，我做了一个超精简版本的重现代码：\n\n```html\n<template>\n  <div>\n    <pre>{{ data.list }}</pre>\n    <p>\n      <button type="button" @click="add">添加</button>\n    </p>\n  </div>\n</template>\n<script lang="ts" setup>\nimport { reactive } from \'vue\';\nimport { getItems, onItemsChange, addItem } from \'./item-service\'\n\nconst data = reactive({\n  list: [] as string[],\n})\n\ngetItems().then((res) => data.list = res).catch(console.error)\nonItemsChange((list) => data.list = list)\n\nfunction add() {\n  addItem(new Date().toLocaleString())\n}\n<\/script>\n```\n\nitem-service 代码：\n\n```ts\n// 条目列表缓存对象\nlet _items: string[] | undefined = undefined\n\ntype Listener = (items: string[]) => void\nconst listeners: Array<Listener> = []\n\nexport async function getItems(): Promise<string[]> {\n  if (_items) {\n    return _items\n  }\n  // 从服务器请求数据\n  _items = await doAjax()\n  return _items\n}\n\nexport async function addItem(item: string) {\n  const items = await getItems()\n  items.push(item)\n  listeners.forEach(listener => listener(items))\n}\n\nexport async function onItemsChange(listener: Listener) {\n  listeners.push(listener)\n}\n```\n\ntem-service 中缓存了列表对象，然后组件中一直使用 item-service 中缓存的这个列表给 data 赋值，问题就出在这。\n\n### 程序调试\n\nvue3 的响应式是通过 Proxy 实现的，我在 onItemsChange 回调时做了调试，下面是 Proxy handler 的 set 方法的调试过程。为了方便查看，调试中没有被执行到的代码都注掉了，并且加了一些说明。\n\n```js\n// 注释掉的代码都是调试过程中没有被执行的代码\nfunction set(target, key, value, receiver) {\n  // 代理 handler 的 set 方法参数说明：\n  // target 原始对象，getItems() 返回的 list\n  // key 属性名称，‘list’\n  // value 要设置的值，onItemsChange 回调的 list 对象\n  // receiver 最初被调用的对象,通常是 proxy 本身，这里就是 data.list， list的代理对象\n  let oldValue = target[key];\n  // 使用 shallowReactive 的情况下 shallow 标记是 true ，这里是 false\n  if (!shallow && !isReadonly(value)) {\n    value = toRaw(value);\n    oldValue = toRaw(oldValue);\n    // export const isArray = Array.isArray\n    // !isArray(target) 返回 false\n    if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n      // oldValue.value = value;\n      // return true;\n    }\n  }\n  const hadKey =\n    isArray(target) && isIntegerKey(key) // isIntegerKey(key) 返回 false，下行不执行\n      // ? Number(key) < target.length\n      : hasOwn(target, key); // true\n  // 使用反射设置值，相当于 data.list = list\n  const result = Reflect.set(target, key, value, receiver);\n  // don\'t trigger if target is something up in the prototype chain of original\n  // 如果 target 是被代理的原始对象原型链上的某个对象就不触发\n  // 实际上原始对象就是 target\n  if (target === toRaw(receiver)) {\n    if (!hadKey) {\n      // 没有 key （\'list\'）属性，就触发 add\n      // hadKey = true\n      // trigger(target, "add" /* ADD */, key, value);\n    } else if (hasChanged(value, oldValue)) {\n      // hasChanged = (value: any, oldValue: any): boolean => !Object.is(value, oldValue)\n      // value 和 oldValue 是同一个 list 数组对象, hasChanged 返回 false\n      // trigger(target, "set" /* SET */, key, value, oldValue);\n    }\n  }\n  return result;\n}\n```\n\n可以看到没有触发任何更新，因此没有响应。\n\n### 原因总结\n\n原因总算确定了，其实就是因为被代理的数组，和要赋值的数组是同一个数据，在 Proxy 的回调中判定值没有改变，没有触发更新。\n\n```js\n// data.list 是 list 的代理对象，将 data.list 提取原始值（toRaw）就是 list\ndata.list = list\n```\n\n处理的方法也比较简单，将数组简单的克隆下，就没有问题了。\n\n```js\ngetItems().then((res) => data.list = [...res]).catch(console.error)\nonItemsChange((list) => data.list = [...list])\n```\n\n我这种情况是由于缓存数据共享对象引起的，对于需要共享数据的项目，还可以使用状态管理组件，vuex 或 pinia。\n\n### 普通对象是否也有同样问题？\n\n既然是因为复用数组，代理回调因为值没有改变最终没有触发更新，那么对象是否也存在这样的问题呢，我写了个简单的代码验证了下：\n\n```html\n<template>\n  <div>\n    <pre>{{ data.user }}</pre>\n    <p>\n      <button type="button" @click="changeAge"> change age</button>\n    </p>\n  </div>\n</template>\n<script setup lang="ts">import { reactive } from \'vue\';\nconst user = { name: \'Tony\', age: 44 }\n\nconst data = reactive({\n  user: { name: \'\', age: 1 }\n})\n\ndata.user = user\n\nfunction changeAge() {\n  user.age = Math.round(Math.random() * 100)\n  data.user = user\n}\n<\/script>\n```\n\n答案是肯定的，问题仍然存在。如果存在这种情况，可以将对象克隆下（使用 Object.assign() 或其它的方法）得到一个新的对象，再给响应式数据赋值来解决。\n',s=t("f373");Object(r["c"])(Object(s["a"])(a)).mount("#app")}});