(function(e){function n(n){for(var c,d,u=n[0],o=n[1],i=n[2],g=0,s=[];g<u.length;g++)d=u[g],Object.prototype.hasOwnProperty.call(l,d)&&l[d]&&s.push(l[d][0]),l[d]=0;for(c in o)Object.prototype.hasOwnProperty.call(o,c)&&(e[c]=o[c]);b&&b(n);while(s.length)s.shift()();return r.push.apply(r,i||[]),t()}function t(){for(var e,n=0;n<r.length;n++){for(var t=r[n],c=!0,u=1;u<t.length;u++){var o=t[u];0!==l[o]&&(c=!1)}c&&(r.splice(n--,1),e=d(d.s=t[0]))}return e}var c={},l={"blogs/2022/wechat-moments-dbd":0},r=[];function d(n){if(c[n])return c[n].exports;var t=c[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,d),t.l=!0,t.exports}d.m=e,d.c=c,d.d=function(e,n,t){d.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},d.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},d.t=function(e,n){if(1&n&&(e=d(e)),8&n)return e;if(4&n&&"object"===typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(d.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var c in e)d.d(t,c,function(n){return e[n]}.bind(null,c));return t},d.n=function(e){var n=e&&e.__esModule?function(){return e["default"]}:function(){return e};return d.d(n,"a",n),n},d.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},d.p="/";var u=window["webpackJsonp"]=window["webpackJsonp"]||[],o=u.push.bind(u);u.push=n,u=u.slice();for(var i=0;i<u.length;i++)n(u[i]);var b=o;r.push([14,"chunk-vendors","chunk-common"]),t()})({14:function(e,n,t){e.exports=t("63ec")},"63ec":function(e,n,t){"use strict";t.r(n);var c=t("f2bf"),l=t("8c98"),r=t("6226");const d=Object(c["g"])("p",null," 今天聊一下类似微信朋友圈这样的业务该怎么设计数据库的表结构，纯个人观点，希望能够提供一点参考价值。 ",-1),u=Object(c["g"])("p",null," 数据库使用 MongoDB，因为 MongoDB 比较灵活，支持属性层级较复杂的数据存储，并且可以为这些属性设置索引，有些情况使用 mysql 可能要创建不少关联表然后联表查询，使用 MongoDB 程序能更简洁一些。此外 MongoDB 支持分片集群，对于数据量大的业务承载能力更好一些，下面涉及创建集合（相当于mysql中的表）的部分也会有分区键。 ",-1),o=Object(c["g"])("h3",null,"约定",-1),i=Object(c["g"])("p",null," 为了直观易读，所有的集合中的数据结构都使用 TypeScript 的接口定义来表示。由于习惯问题，后面出现的 mongo 的集合，统一称作为表。 ",-1),b=Object(c["g"])("h3",null,"联系人",-1),g=Object(c["g"])("p",null,"系人表记录自己有哪些好友。",-1),s=Object(c["g"])("p",null,"创建唯一索引：",-1),a=Object(c["g"])("h3",null,"联系人标签",-1),j=Object(c["g"])("p",null," 微信中有个给联系人打标签的功能，朋友圈动态可以使用标签来设置权限，所以我们要创建一个联系人标签表。 ",-1),O=Object(c["g"])("p",null,"创建唯一索引，将 userId 放前面，方便使用 userId 查询自己被好友打上了哪些标签。",-1),p=Object(c["g"])("h3",null,"联系人权限",-1),I=Object(c["g"])("p",null," 微信中可以对联系人设置朋友圈权限：不看他（她）、不让他（她）看我。所以我们增加一个权限设置表。 ",-1),f=Object(c["g"])("p",null,"为 reverseExcludedUserIds 创建索引，用于查询自己被哪些好友屏蔽。",-1),y=Object(c["g"])("h3",null,"群",-1),h=Object(c["g"])("p",null,"朋友圈的动态可以设置根据群设置权限，所以必须得得增加群用户这个表。",-1),v=Object(c["g"])("p",null,"创建唯一索引，将 userId 放前面，方便查询自己所在的群。",-1),m=Object(c["g"])("h3",null,"朋友圈动态",-1),D=Object(c["g"])("p",null," 微信朋友圈在发动态时，可以设置谁可以看：公共（所有人）、私密（仅自己）、部分可见（可设置人、群和标签）、不给谁看（可设置人、群和标签）。这些设置是单选的，只能选择一个。 ",-1),_=Object(c["g"])("p",null,"下面是动态表的数据结构：",-1),x=Object(c["g"])("p",null," 本文主要说明如何做查询，内容等字段不出现在查询语句中，此处省略，不做相关的介绍。然后我们为创建人id和_id创建索引，以方便后面按时间顺序查询记录。 ",-1),w=Object(c["g"])("p",null," 动态表可以将 creatorId 设置为分区键，这样不同的用户的数据会分布在不同的节点上，在写入数据时能避免热片问题。 ",-1),U=Object(c["g"])("h3",null,"查询流程",-1),S=Object(c["g"])("p",null,"相关的表都已经创建好了，现在可以开始做查询逻辑了。",-1),T=Object(c["g"])("h4",null,"获取朋友圈可见的好友ID列表",-1),$=Object(c["g"])("p",null,"从联系人集合中查询当前用户所有好友的ID，在程序中存为 contactIds 。",-1),M=Object(c["g"])("p",null,[Object(c["i"])(" 从动态设置集合中查询当前用户被哪些好友屏蔽，得到这些好友的ID，在程序中存为 "),Object(c["g"])("code",null,"unfriendlyContactIds"),Object(c["i"])(" 。 ")],-1),P=Object(c["g"])("p",null,[Object(c["i"])(" 从动态设置表中查询当前用户屏蔽了哪些好友，得到这些好友的ID，在程序中存为 "),Object(c["g"])("code",null,"excludedUserIds"),Object(c["i"])(" 。 ")],-1),C=Object(c["g"])("p",null,[Object(c["i"])(" 然后从 "),Object(c["g"])("code",null,"contactIds"),Object(c["i"])(" 删除掉 "),Object(c["g"])("code",null,"unfriendlyContactIds"),Object(c["i"])(" 和 "),Object(c["g"])("code",null,"excludedUserIds"),Object(c["i"])(" 中包含的用户ID，得到所有可以查看朋友圈的好友ID，在程序中记为 "),Object(c["g"])("code",null,"friendlyContactIds"),Object(c["i"])(" 。 ")],-1),k=Object(c["g"])("h4",null,"获取所有标签ID",-1),q=Object(c["g"])("p",null,[Object(c["i"])(" 从联系人标签集合中查询当前用户被好友打上的所有标签的ID，在程序中存为 "),Object(c["g"])("code",null,"tagIds"),Object(c["i"])(" 。 ")],-1),B=Object(c["g"])("h4",null,"获取所有群组ID",-1),E=Object(c["g"])("p",null,[Object(c["i"])("从君用户集合中查询当前用户所在的所有群ID，在程序中记为 "),Object(c["g"])("code",null,"groupIds"),Object(c["i"])(" 。")],-1),J=Object(c["g"])("h4",null,"查询动态表",-1),G=Object(c["g"])("p",null,"经过前面的几次查询，我们得到以下数据：",-1),z=Object(c["g"])("div",{class:"table-responsive"},[Object(c["g"])("table",{class:"table table-bordered"},[Object(c["g"])("thead",null,[Object(c["g"])("tr",null,[Object(c["g"])("th",null,"变量名称"),Object(c["g"])("th",null,"说明")])]),Object(c["g"])("tbody",null,[Object(c["g"])("tr",null,[Object(c["g"])("td",null,"friendlyContactIds"),Object(c["g"])("td",null,"朋友圈可见的好友id列表")]),Object(c["g"])("tr",null,[Object(c["g"])("td",null,"tagIds"),Object(c["g"])("td",null,"被所有好友打上的标签id列表")]),Object(c["g"])("tr",null,[Object(c["g"])("td",null,"groupIds"),Object(c["g"])("td",null,"加入的所有群组id列表")])])])],-1),A=Object(c["g"])("p",null," 有了这些信息，就可以从动态集合（表）中查询记录了。上面的信息不需要每次都重新查询一次，可以查询后缓存一段时间，一般情况下很少会有改动，加载新动态时可直接复用。 ",-1),F=Object(c["g"])("p",null," 上面的查询语句中需要程序中动态插入前面查询到的数据记录，_id 的过虑条件用于翻页，首次查询不需要。查询主要依赖于动态表的字段 creatorId 和 _id 联合索引，群组ID、标签ID和用户ID没有必要创建索引，意义不大。 ",-1),H=Object(c["g"])("h3",null,"总结",-1),K=Object(c["g"])("p",null," 整个流程没有什么复杂的查询，仅最后查询动态表稍微麻烦一点点。随着好友数量的增加，查询的效率会有所降低，所以业务上需要限制好友的数量。 ",-1);var L=Object(c["k"])({setup(e){return(e,n)=>(Object(c["r"])(),Object(c["d"])(l["a"],null,{default:Object(c["G"])(()=>[d,u,o,i,b,g,Object(c["j"])(r["a"],{code:"\n      interface contact {\n        _id: string\n        /**\n        * 用户id.\n        */\n        userId: string\n        /**\n        * 好友id.\n        */\n        contactId: string\n        // 其它属省略，不会出现在后面的查询中\n      }",language:"ts"}),s,Object(c["j"])(r["a"],{code:"db.contact.createIndex({userId: 1, contactId: 1}, {unique: true})"}),a,j,Object(c["j"])(r["a"],{code:"\n      interface contactTag {\n        _id: string;\n        /**\n        * 创建人ID.\n        */\n        creatorId:string;\n        /**\n        * 用户ID.\n        */\n        userId: string;\n        /**\n        * 标签ID.\n        */\n        tagId: string;\n      }",language:"ts"}),O,Object(c["j"])(r["a"],{code:"db.contactTag.createIndex({userId: 1, tagId: 1}, {unique: true})"}),p,I,Object(c["j"])(r["a"],{code:"\n      interface momentSetting {\n        /**\n        * 与用户id一对一关联.\n        */\n        _id: string\n        /**\n        * 被排除的用户ID，不看他（她）.\n        */\n        excludedUserIds: string[]\n        /**\n        * 反向排除的用户ID，不让他（她）看我.\n        */\n        reverseExcludedUserIds: string[]\n      }",language:"ts"}),f,Object(c["j"])(r["a"],{code:"db.momentSetting.createIndex({reverseExcludedUserIds: 1})"}),y,h,Object(c["j"])(r["a"],{code:"\n      interface groupUser {\n        _id: string\n        /**\n        * 微信群id.\n        */\n        groupId: string\n        /**\n        * 用户id.\n        */\n        userId: string\n      }",language:"ts"}),v,Object(c["j"])(r["a"],{code:"db.groupUser.createIndex({userId: 1, groupId: 1}, {unique: true})"}),m,D,_,Object(c["j"])(r["a"],{code:"\n      interface moment {\n        /**\n        * 带有时间顺序的id，由时间戮加随机数生成.\n        */\n        _id: string\n        /**\n        * 作者id.\n        */\n        creatorId: string\n        /**\n        * 开放类型，公开、私密，部分人等. public 表示公开，private 表示私密，\n        * partly-visible 表示部分可见，partly-invisible 表示部分人不可见（不让谁看）.\n        * 当值为 partly-visible 或 partly-invisible，下面的几个属性才有效.\n        */\n        openType: 'public' | 'private' | 'partly-visible' | 'partly-invisible',\n        /**\n        * 受限或开放的群组id列表.\n        */\n        groupIds: string[]\n        /**\n        * 受限或开放的标签id列表.\n        */\n        tagIds: string[]\n        /**\n        * 受限或开放的用户id列表.\n        */\n        userIds: string[]\n        // 其它的属性，如内容、创建时间等字段此处省略，这些字段不出现在查询语句中\n      }",language:"ts"}),x,Object(c["j"])(r["a"],{code:"db.moment.createIndex({creatorId: 1, _id: -1})"}),w,Object(c["j"])(r["a"],{code:'sh.shardCollection( "库名.moment", { "creatorId" : "hashed" } )'}),U,S,T,$,Object(c["j"])(r["a"],{code:"db.contact.find({userId:'当前用户ID'},{contactId:1})"}),M,Object(c["j"])(r["a"],{code:"db.momentSetting.find({reverseExcludedUserIds:'当前用户ID'},{_id:1})"}),P,Object(c["j"])(r["a"],{code:"db.momentSetting.find({_id:'当前用户ID'},{excludedUserIds:1})"}),C,k,q,Object(c["j"])(r["a"],{code:"db.contactTag.find({userId:'当前用户ID'},{tagId:1})"}),B,E,Object(c["j"])(r["a"],{code:"db.groupUser.find({userId:'当前用户ID'},{groupId:1})"}),J,G,z,A,Object(c["j"])(r["a"],{code:"\n    db.moment.find({\n      creatorId: {$in: '插入 friendlyContactIds'}\n      _id: {$gt: '上次查询最后一条记录的ID'},\n      $or: [\n          {openType: 'public'},\n          {\n              openType: 'partly-visible',\n              $or: [\n                  {groupIds: {$in: '插入 groupIds'}},\n                  {tagIds: {$in: '插入 tagIds'}},\n                  {userIds: '当前用户ID'}\n              ]\n          },\n          {\n              openType: 'partly-invisible',\n              $and: [\n                  {groupIds: {$nin: '插入 groupIds'}},\n                  {tagIds: {$nin: '插入 tagIds'}},\n                  {userIds: {$ne: '当前用户ID'}}\n              ]\n          }\n      ]\n    }).sort({_id: -1}).limit(20)\n    ",language:"js"}),F,H,K]),_:1}))}});const N=L;var Q=N;Object(c["c"])(Q).mount("#app")}});