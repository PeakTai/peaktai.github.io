(function(t){function e(e){for(var c,o,s=e[0],i=e[1],r=e[2],d=0,u=[];d<s.length;d++)o=s[d],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&u.push(a[o][0]),a[o]=0;for(c in i)Object.prototype.hasOwnProperty.call(i,c)&&(t[c]=i[c]);p&&p(e);while(u.length)u.shift()();return l.push.apply(l,r||[]),n()}function n(){for(var t,e=0;e<l.length;e++){for(var n=l[e],c=!0,s=1;s<n.length;s++){var i=n[s];0!==a[i]&&(c=!1)}c&&(l.splice(e--,1),t=o(o.s=n[0]))}return t}var c={},a={"blogs/2022/css3-pie":0},l=[];function o(e){if(c[e])return c[e].exports;var n=c[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=t,o.c=c,o.d=function(t,e,n){o.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},o.r=function(t){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},o.t=function(t,e){if(1&e&&(t=o(t)),8&e)return t;if(4&e&&"object"===typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(o.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var c in t)o.d(n,c,function(e){return t[e]}.bind(null,c));return n},o.n=function(t){var e=t&&t.__esModule?function(){return t["default"]}:function(){return t};return o.d(e,"a",e),e},o.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},o.p="/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],i=s.push.bind(s);s.push=e,s=s.slice();for(var r=0;r<s.length;r++)e(s[r]);var p=i;l.push([8,"chunk-vendors","chunk-common"]),n()})({8:function(t,e,n){t.exports=n("ffcf")},"953a":function(t,e,n){},d5a9:function(t,e,n){"use strict";n("953a")},ffcf:function(t,e,n){"use strict";n.r(e);var c=n("f2bf"),a=n("6226"),l=n("8c98");const o=t=>(Object(c["t"])("data-v-43af9bb5"),t=t(),Object(c["s"])(),t),s=o(()=>Object(c["g"])("p",null," 开发中常常有做统计图的需求，主流的前端插件都是基于 canvas 来做的， 那么使用 css3 能不能实现呢？今天我来尝试一下使用 css3 做一个饼图效果。 ",-1)),i=o(()=>Object(c["g"])("h3",null,"渐变背景",-1)),r=o(()=>Object(c["g"])("p",null," css3 在背景图片中增加了渐变，使用锥形渐变（conic-gradient）我们可以很方便的就实现一个饼图。 ",-1)),p={class:"row row-cols-1 row-cols-md-2"},d=o(()=>Object(c["g"])("div",{class:"col text-center text-md-start"},[Object(c["g"])("div",{class:"pie d-inline-block"})],-1)),u={class:"col"},b=o(()=>Object(c["g"])("p",null," 上面的效果就是渐变背景实现的，通过圆角将元素显示成圆形，再通过锥形渐变， 围绕着中心点给划分区域填充颜色就可以了。这个方法实现起来非常的简单，适合要求不高的场景。如果想要有点动态效果，比如说鼠标悬停在扇区内， 扇区突出显示或者显示扇区对应的数据，可能就无法满足了。 ",-1)),g=o(()=>Object(c["g"])("p",null,[Object(c["i"])(" 参考文档："),Object(c["g"])("a",{target:"_blank",href:"https://developer.mozilla.org/en-US/docs/web/css/gradient/conic-gradient"},"conic-gradient() - CSS: Cascading Style Sheets | MDN"),Object(c["i"])("。 ")],-1)),h=o(()=>Object(c["g"])("h3",null,"元素形状剪裁",-1)),f=o(()=>Object(c["g"])("p",null,[Object(c["i"])(" 既然要给不同的扇区添加动态效果，必须得让每个扇都是一个元素，然后给元素添加事件或添加伪类样式。那么怎么样才可以让元素显示成扇形的样子呢？这个我们可以通过 clip-path 来实现，clip-path 使用裁剪方式创建元素的可显示区域，区域内的部分显示，区域外的隐藏。clip-path 支持四种图形裁剪：inset，circle，polygon，path，这里我们使用 path 来直接裁剪出扇形。通过圆角将元素变成圆形，然后再使用多边形（polygon）裁剪也可以得到扇形，但是会复杂非常多。关于 clip-path 的详细信息，可参考文档： "),Object(c["g"])("a",{target:"_blank",href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path"},"clip-path - CSS（层叠样式表） | MDN"),Object(c["i"])("。 ")],-1)),j=o(()=>Object(c["g"])("h4",null,"准备数据",-1)),O=o(()=>Object(c["g"])("p",null," 下图是 tiobe 2022 编程语言排行，太长我只截取了一部分，为了简单不在图中的部分归到 other 中。 ",-1)),m=o(()=>Object(c["g"])("figure",null,[Object(c["g"])("img",{src:"/assets/blogs/2022/css3-pie/tiobe-2022.png",class:"img-fluid",alt:"tiobe-2022"}),Object(c["g"])("figcaption",null,"toobe-2022")],-1)),v=o(()=>Object(c["g"])("p",null,"最后得到的统计数据是这样的：",-1)),y=o(()=>Object(c["g"])("h4",null,"计算路径",-1)),x=o(()=>Object(c["g"])("p",null," 接下来做一个函数来计算出样式，clip-path 中的 path 模式和 svg 中的 path 是一样的，我们主要用到4个命令：M 移动，L 绘制直线，A 绘制弧形，Z 关闭路径。 ",-1)),M=o(()=>Object(c["g"])("p",null,[Object(c["g"])("img",{src:"/assets/blogs/2022/css3-pie/clip-path-1.png",alt:"clip-path 路径说明",class:"img-fluid"})],-1)),w=o(()=>Object(c["g"])("p",null,"上面是裁剪的路径流程示意图，中心点是固定的，需要计算出圆弧上的起止的两个坐标点。",-1)),P=o(()=>Object(c["g"])("p",null,[Object(c["g"])("img",{src:"/assets/blogs/2022/css3-pie/clip-path-2.png",alt:"cli-path 角度计算",class:"img-fluid"})],-1)),S=o(()=>Object(c["g"])("p",null," 按图上的方法来计算坐标点（超出 90 度也适用），编写计算一个函数来计算对应百分比在圆弧上的点坐标。 ",-1)),$=o(()=>Object(c["g"])("p",null,"继续编写计算扇区路径的函数：",-1)),k=o(()=>Object(c["g"])("h4",null,"完成饼图布局",-1)),C=o(()=>Object(c["g"])("p",null,"基础样式：",-1)),_=o(()=>Object(c["g"])("p",null,"完成生成饼图函数，并执行：",-1)),E=o(()=>Object(c["g"])("p",null,"最后我们得到一个饼图：",-1)),L=o(()=>Object(c["g"])("p",{class:"text-center"},[Object(c["g"])("img",{src:"/assets/blogs/2022/css3-pie/rendering-1.png",alt:"效果图",class:"img-fluid",style:{height:"250px"}})],-1)),I=o(()=>Object(c["g"])("h4",null,"添加交互效果",-1)),J=o(()=>Object(c["g"])("p",null," 到这里就和之前使用背景图渐变实现的效果一样了，但是每一个扇区都是一个 dom 元素，这意味着我们可以给它加样式或加事件来实现动态效果。那么继续改造一下， 让鼠标悬停在扇区的时候突出扇区，并显示对应的标题。在每 .sector 的后面加一个兄弟元素 .title，当 .sector 有鼠标悬停的时候 title 才在右侧显示出来。此外，再给 .sector 增加一个鼠标悬停放大的效果。 ",-1)),z=o(()=>Object(c["g"])("p",null,"代码稍微改一下，在扇区后面加一个标题元素",-1)),N=o(()=>Object(c["g"])("p",null," 看看最终的效果（将鼠标放上去会有交互效果，ie 和很多移动端浏览器由于兼容性问题可能看不到效果）： ",-1)),T=o(()=>Object(c["g"])("iframe",{src:"/assets/blogs/2022/css3-pie/css3-pie.html",style:{width:"100%",height:"380px"}},null,-1)),A=o(()=>Object(c["g"])("h3",null,"总结",-1)),B=o(()=>Object(c["g"])("p",null," 使用 css3 实现饼图整体上比基于 canvas 简单一些，毕竟基于 canvas 的话除了绘制状态外还需要实现元素边缘判定和事件绑定机制，而这些 dom 本来就有的，有些交互不需要写 js 直接 css 就可以实现，你只管裁剪出需要的形状就好。但是，path 裁剪的兼容性不是很好，ie 就别想了，移动端很多浏览器也不支持，使用需谨慎。 ",-1)),D=o(()=>Object(c["g"])("p",null,[Object(c["i"])(" 最后附上完整代码，"),Object(c["g"])("a",{target:"_blank",href:"/assets/blogs/2022/css3-pie/css3-pie.html"},"点击此处可下载 html 文件"),Object(c["i"])("。 ")],-1));var Z=Object(c["k"])({setup(t){return(t,e)=>(Object(c["r"])(),Object(c["d"])(l["a"],null,{default:Object(c["G"])(()=>[s,i,r,Object(c["g"])("div",p,[d,Object(c["g"])("div",u,[Object(c["j"])(a["a"],{code:"\n        .pie {\n          width: 300px;\n          height: 300px;\n          border-radius: 50%;\n          background: conic-gradient(\n            blue 36deg,\n            green 36deg 170deg,\n            cadetblue 170deg);\n        }"})])]),b,g,h,f,j,O,m,v,Object(c["j"])(a["a"],{code:"\n      const data = [\n        {ratio: 0.1358, title: 'Python 13.58%'},\n        {ratio: 0.1244, title: 'C 12.44%'},\n        {ratio: 0.1066, title: 'Java 10.66%'},\n        {ratio: 0.0829, title: 'C++ 8.29%'},\n        {ratio: 0.0568, title: 'C# 5.68%'},\n        {ratio: 0.0474, title: 'Visual Basic 4.74%'},\n        {ratio: 0.0209, title: 'JavaScript 2.09%'},\n        {ratio: 0.4252, title: 'Other 42.52%'},\n      ]\n    ",language:"js"}),y,x,M,w,P,S,Object(c["j"])(a["a"],{code:"\n    function execPoint(cx, cy, r, ratio) {\n        // 计算弧度，一个整圆弧度是 2π\n        const rad = ratio* 2 * Math.PI\n        return {\n            x: cx + Math.sin(rad) * r,\n            y: cy - Math.cos(rad) * r\n        }\n    }\n    ",language:"js"}),$,Object(c["j"])(a["a"],{code:"\n    function buildSectorPaths(data, width) {\n      // 偏转量\n      let offset = 0\n      // 圆心坐标\n      const cx = width / 2\n      const cy = width / 2\n      // 半径\n      const r = width / 2\n      const result = []\n      for (const datum of data) {\n        let path = `M ${cx},${cy}`\n        // 圆弧起点\n        const start = execPoint(cx, cy, r, offset)\n        path += ` L ${start.x},${start.y}`\n        // 圆弧终点\n        offset += datum.ratio\n        const end = execPoint(cx, cy, r, offset)\n        // 圆弧大于半圆画大圆，否则画小圆\n        const angle = datum.ratio * 2 * Math.PI\n        path += ` A ${r},${r} 0,${angle > Math.PI ? 1 : 0},1 ${end.x},${end.y}`\n        path += ' Z'\n        result.push(path)\n      }\n      return result\n    }"}),k,C,Object(c["j"])(a["a"],{code:"\n    .pie {\n      width: 300px;\n      height: 300px;\n      position: relative;\n    }\n\n    .pie .sector {\n      position: absolute;\n      width: 100%;\n     height: 100%;\n    }",language:"css"}),_,Object(c["j"])(a["a"],{code:"\n    function buildPie(containerEl, data) {\n      containerEl.classList.add('pie')\n      const paths = buildSectorPaths(data, 300)\n      for (let path of paths) {\n        const sector = document.createElement('div')\n          sector.classList.add('sector')\n          sector.style.clipPath = `path('${path}')`\n          // 给个随机背景色\n          const r = Math.floor(Math.random() * 255);\n          const g = Math.floor(Math.random() * 255);\n          const b = Math.floor(Math.random() * 255);\n          sector.style.backgroundColor = `rgb(${r},${g},${b})`\n          containerEl.appendChild(sector)\n      }\n    }\n\n    const pie = document.getElementById('pie')\n    buildPie(pie, data)"}),E,L,I,J,Object(c["j"])(a["a"],{code:"\n    .pie .sector {\n      position: absolute;\n      width: 100%;\n      height: 100%;\n      transition: all .3s ease-in;\n    }\n\n    .pie .sector:hover {\n      transform: scale(1.1);\n    }\n\n    .pie .title {\n      display: none;\n    }\n\n    .pie .sector:hover + .title {\n      position: absolute;\n      top: 50%;\n      left: 110%;\n      width: 120px;\n      transform: translateY(-50%);\n      display: block;\n    }",language:"css"}),z,Object(c["j"])(a["a"],{code:"\n    function buildPie(containerEl, data) {\n      containerEl.classList.add('pie')\n      const paths = buildSectorPaths(data, 300)\n      for (let i = 0; i < paths.length; i++) {\n        const path = paths[i]\n        const sector = document.createElement('div')\n        sector.classList.add('sector')\n        sector.style.clipPath = `path('${path}')`\n        // 给个随机背景色\n        const r = Math.floor(Math.random() * 255);\n        const g = Math.floor(Math.random() * 255);\n        const b = Math.floor(Math.random() * 255);\n        sector.style.backgroundColor = `rgb(${r},${g},${b})`\n        containerEl.appendChild(sector)\n        // 新增加的标题\n        const title = document.createElement('div')\n        title.classList.add('title')\n        title.innerText = data[i].title\n        containerEl.appendChild(title)\n      }\n    }"}),N,T,A,B,D]),_:1}))}}),G=(n("d5a9"),n("6b0d")),U=n.n(G);const V=U()(Z,[["__scopeId","data-v-43af9bb5"]]);var W=V;Object(c["c"])(W).mount("#app")}});