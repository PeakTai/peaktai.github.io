(function(e){function n(n){for(var r,o,s=n[0],c=n[1],l=n[2],d=0,p=[];d<s.length;d++)o=s[d],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&p.push(a[o][0]),a[o]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(e[r]=c[r]);u&&u(n);while(p.length)p.shift()();return i.push.apply(i,l||[]),t()}function t(){for(var e,n=0;n<i.length;n++){for(var t=i[n],r=!0,s=1;s<t.length;s++){var c=t[s];0!==a[c]&&(r=!1)}r&&(i.splice(n--,1),e=o(o.s=t[0]))}return e}var r={},a={"blogs/2022/java12-features":0},i=[];function o(n){if(r[n])return r[n].exports;var t=r[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.m=e,o.c=r,o.d=function(e,n,t){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,n){if(1&n&&(e=o(e)),8&n)return e;if(4&n&&"object"===typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)o.d(t,r,function(n){return e[n]}.bind(null,r));return t},o.n=function(e){var n=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],c=s.push.bind(s);s.push=n,s=s.slice();for(var l=0;l<s.length;l++)n(s[l]);var u=c;i.push([19,"chunk-vendors","chunk-common"]),t()})({"18fe":function(e,n,t){"use strict";t.r(n);var r=t("f2bf"),a='### 支持 Unicode 11\n\n新增加 684 个字符，11 个块，7 个脚本。unicode 目前最新版本是 14.0 ，java 已经于 15 版本中支持到了 13。\n\n### 在 linux 系统上支持 POSIX_SPAWN\n\n可通过将系统属性 jdk.lang.Process.launchMechanismproperty 设置为 POSIX_SPAWN 在 linux 系统上使用 posix_spawn 创建子进程，默认是 vfork 。\n\n### JVM 常量 API\n\n引入新的 API 来对字节码文件和运行时工件的名义描述（nominal descriptions）进行建模，特别是可从（字码码文件）常量池加载的常量。\n\n每一个字节码文件都有一个常量池，用来存储字节码指令的操作数。常量池中的条目要么描述类和方法等运行时工件，要么描述字符串和整数等简单值。这些条目被称为可加载常量，因为它们可以作为“ldc”指令的操作数。\n\n新增加的类：ConstantDesc、ClassDesc,MethodTypeDesc,MethodHandleDesc, 和DynamicConstantDesc 。这套 API 的添加旨在提供一个标准的模型，可供一些底层库使用，例如字节码解析和生成的库 ASM、反射库等。大多数 Java 开发人员不需要使用它。\n\n### 支持数字的紧凑格式化\n\nNumberFormat 增加了对以紧凑形式格式化数字的支持，紧凑格式是一种短并且人类可读的格式，比如 1K 表示 1000，1M 表示100万。\n\n```java\nNumberFormat fmt = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\nString result = fmt.format(1000);// 1K\n```\n\n### 支持日本新年号的方形字符\n\n> 2019年4月1日，日本官房长官菅义伟宣布，“令和”被选为日本新年号，是日本第126代天皇的年号。2019年4月3日，日本外务省就新年号“令和”向外国媒体公布了官方英文翻译：“Beautiful Harmony”，为“美丽和谐”之意。2019年5月1日零时（日本东京时间），日本正式启用“令和”为年号。\n\nunicode 代码 U+32FF 用于表示 ㋿ ，这次 jdk 也做了支持。\n\n```java\nString 令和 =  "\\u32FF"\n```\n\n### ZGC 并发类卸载\n\nZGC 现在支持类的卸载了，并且是并发执行的，不会对 gc 时间产生影响。这个特性默认是开启的，可以通过参数 -XX:-ClassUnloading 来禁用。\n\n### 在备用内存设备上分配老年代\n\nG1 和并行 GC 增加了实验性功能，允许他们将 Java 堆的老年代分配到备用内存设备上，例如 NV-DIMM 内存。当今的操作系统通过文件系统暴露 NV-DIMM 内存设备，可以通过参数 -XX:AllocateOldGenAt=<path> 指定路径来启用此特性。\n\n### HotSpot 可以正确检测 windows server 2019\n\n之前 Windows Server 2019 会被识别为 Windows Server 2016。\n\n### 命令行参数 -XX+ExtensiveErrorReports\n\n-XX+ExtensiveErrorReports 参数允许将更多关于崩溃的报告信息写入错误日志 hs_err<pid>.log 中。默认是关闭的，在一些需要最大的信息的情况下可以开启。\n\n### 系统属性 java.security.manager \n\n可以对系统属性 java.security.manager 设置两个值：disallow 和 allow。如果设置为 disallow , System.setSecurityManager 将不能调用，抛出异常：UnsupportedOperationException。SecurityManager 在 jdk17 中已经被废弃了。\n\n### keytool 添加参数 -groupname\n\nkeytool -genkeypair 添加了新的 -groupname 选项，以便用户在生成密钥对时可以指定命名组。\n\n```\nkeytool -genkeypair -keyalg EC -groupname secp384r1\n```\n\n### JFR （Java Flight Recorder）添加新事件\n\nJFR 新增加了4个事件：\n\n- jdk.SecurityPropertyModification\n- jdk.TLSHandshake\n- jdk.X509Validation\n- jdk.X509Certificate\n\n### 自定义 PKCS12 密钥生成\n\n添加了新的系统属性和安全属性用于自定义PKCS #12 密钥，可以 java.security 文件中进行配置，在 PKCS12 KeyStore properties 章节中可以找到详细的属性配置。\n\n下面是 jdk 安装目录下 conf/java.security 文件的相关配置：\n\n```properties\n#\n# PKCS12 KeyStore properties\n#\n# The following properties, if configured, are used by the PKCS12 KeyStore\n# implementation during the creation of a new keystore. Several of the\n# properties may also be used when modifying an existing keystore. The\n# properties can be overridden by a KeyStore API that specifies its own\n# algorithms and parameters.\n#\n# If an existing PKCS12 keystore is loaded and then stored, the algorithm and\n# parameter used to generate the existing Mac will be reused. If the existing\n# keystore does not have a Mac, no Mac will be created while storing. If there\n# is at least one certificate in the existing keystore, the algorithm and\n# parameters used to encrypt the last certificate in the existing keystore will\n# be reused to encrypt all certificates while storing. If the last certificate\n# in the existing keystore is not encrypted, all certificates will be stored\n# unencrypted. If there is no certificate in the existing keystore, any newly\n# added certificate will be encrypted (or stored unencrypted if algorithm\n# value is "NONE") using the "keystore.pkcs12.certProtectionAlgorithm" and\n# "keystore.pkcs12.certPbeIterationCount" values defined here. Existing private\n# and secret key(s) are not changed. Newly set private and secret key(s) will\n# be encrypted using the "keystore.pkcs12.keyProtectionAlgorithm" and\n# "keystore.pkcs12.keyPbeIterationCount" values defined here.\n#\n# In order to apply new algorithms and parameters to all entries in an\n# existing keystore, one can create a new keystore and add entries in the\n# existing keystore into the new keystore. This can be achieved by calling the\n# "keytool -importkeystore" command.\n#\n# If a system property of the same name is also specified, it supersedes the\n# security property value defined here.\n#\n# If the property is set to an illegal value,\n# an iteration count that is not a positive integer, or an unknown algorithm\n# name, an exception will be thrown when the property is used.\n# If the property is not set or empty, a default value will be used.\n#\n# Note: These properties are currently used by the JDK Reference implementation.\n# They are not guaranteed to be examined and used by other implementations.\n\n# The algorithm used to encrypt a certificate. This can be any non-Hmac PBE\n# algorithm defined in the Cipher section of the Java Security Standard\n# Algorithm Names Specification. When set to "NONE", the certificate\n# is not encrypted. The default value is "PBEWithHmacSHA256AndAES_256".\n#keystore.pkcs12.certProtectionAlgorithm = PBEWithHmacSHA256AndAES_256\n\n# The iteration count used by the PBE algorithm when encrypting a certificate.\n# This value must be a positive integer. The default value is 10000.\n#keystore.pkcs12.certPbeIterationCount = 10000\n\n# The algorithm used to encrypt a private key or secret key. This can be\n# any non-Hmac PBE algorithm defined in the Cipher section of the Java\n# Security Standard Algorithm Names Specification. The value must not be "NONE".\n# The default value is "PBEWithHmacSHA256AndAES_256".\n#keystore.pkcs12.keyProtectionAlgorithm = PBEWithHmacSHA256AndAES_256\n\n# The iteration count used by the PBE algorithm when encrypting a private key\n# or a secret key. This value must be a positive integer. The default value\n# is 10000.\n#keystore.pkcs12.keyPbeIterationCount = 10000\n\n# The algorithm used to calculate the optional MacData at the end of a PKCS12\n# file. This can be any HmacPBE algorithm defined in the Mac section of the\n# Java Security Standard Algorithm Names Specification. When set to "NONE",\n# no Mac is generated. The default value is "HmacPBESHA256".\n#keystore.pkcs12.macAlgorithm = HmacPBESHA256\n\n# The iteration count used by the MacData algorithm. This value must be a\n# positive integer. The default value is 10000.\n#keystore.pkcs12.macIterationCount = 10000\n```\n\n### ChaCha20 和Poly1305 TLS 密码库套件\n\n使用 ChaCha20-Poly1305 算法的新 TLS 密码套件已添加到 JSSE（Java Secure Socket Extension）。\n\n### krb5.conf 支持 dns_canonicalize_hostname\n\ndns_canonicalize_hostname 选项表示名称查找是否将使用规范化主机名用于服务主体名称。如果设置为 false，可以通过减少对 DNS 的依赖来提高安全性，但是使用的有可能是短名称，而不是全限域名。这个标记默认是 true ，jdk12 之前也是，只是 jdk12 开始才可以设置。\n\n### jdeps --print-module-deps 报告传递性依赖\n\njdeps 的 --print-module-deps,--list-deps, 和--list-reduce-deps 做了增强，之前显示程序中直接指定的依赖，现在传递依赖的模块也可以被显示出来了。\n\n### Switch 表达式\n\ncase 后的冒号现在可以写成 -> ，后面跟上简短的表达式，并且新语法，不会出现下落的情况了，你不需要写break 。\n\n\n```java\nInteger flag = 1;\nswitch (flag) {\n  case 1:\n    System.out.println("1");\n  case 3:\n    System.out.println("3");\n}\n// 输入 1 3\nSystem.out.println("----------------------");\n// 新语法\nswitch (flag) {\n  case 1 -> System.out.println("1");\n  case 3 -> System.out.println("1");\n}\n// 只输出 1\n```\n\n### 删除 oracle 发行版本号中的 YY.M 供商版本号\n\n11 版本的版本号显示：\n\n```\njava 11 2018-09-25\nJava(TM) SE Runtime Environment 18.9 (build 11+28)\nJava HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)\n```\n\n12 版本的版本号，第二行有区别，没有年月信息版本号：\n\njava 12 2019-03-19\nJava(TM) SE Runtime Environment (build 12+17)\nJava HotSpot(TM) 64-Bit Server VM (build 12+17, mixed mode)\n\n### 其它被删除的特性和选项\n\n- 删除类 com.sun.awt.SecurityWarning\n- FileInputStream 和FileOutputStream 中的 finalize 方法删除，之前的版本已经废弃 finalize 方法绑定资源关闭的操作\n- 删除 java.util.ZipFile/Inflator/Deflator 中的 finalize 方法\n- 删除证书 GTE CyberTrust Global Root\n- javac 不再支持 source, target, 和 release 不再支持 6/1.6\n- 删除 AOL 和 Swisscom 根证书\n- 从 SSLContext 必需算法中删除了 TLS v1 和 v1.1\n\n### 废弃的特性\n\n- 废除选项 -XX:-MonitorInUseLists\n- keytool 中 -keyalg 默认值删除，如果没有指定就会有警告\n- 禁用 TLS anon 和 NULL Cipher Suites\n- 禁用所有 DES TLS 密码套件\n\n### Swing 不再支持 GTK+ 3.20 及更晚的版本\n\n由于 GTK 3.20 版本的不再向前兼容，swing 中部分组件可能会无法正常展示，可以通过参数 -Djdk.gtk.version=2.2 设置系统属性让 jdk 向操作系统请求使用更早的版本。\n\n### 系统属性 user.timezone 发生改变\n\nuser.timezone 如果没有设置，将会使用系统默认。在之前的版本会返回空串，在 jdk12 中 System.getProperty("user.timezone")可能返回 null。\n\n### URLPermission 的 query  和 Fragments 部分特性发生变化\n\n之前已经计划要忽略，只是没有实现，现在按照规范实现了，所以之前可能校验会出错的，现在可以通过。\n\n下面是 URLPermission  地址结构：\n\n```\nscheme : // authority [ / path ] [ ignored-query-or-fragment ]\n```\n\n### Properties.loadFromXML 遵守规范\n\nProperties.loadFromXML 将遵守定义，如果加载的 xml 文件不是 Properties.storeToXML 生成的，并且包含了dtd 定义且不是 Properties.loadFromXML 中指定的格式将会抛出 InvalidPropertiesFormatException 。\n\n下面是 Properties.storeToXML 生成的文件：\n\n```xml\n<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">\n```\n\n### LDAPS 通讯失败\n\n使用 LDAPS 且套接字连接超时 <= 0（默认值）的应用程序代码在建立连接时可能会遇到异常。\n\n### G1 可能在标记阶段取消提交内存\n\n默认情况下 G1 会在并发标记阶段归还内存，这样可以提高内存的利用率。同时，G1 也会遵守 Java 的内存策略，通过 -Xms 参数可以禁用 G1 的这种行为。\n\n### 如果使用了 JVMCI 编辑器 can_pop_frame 和 can_force_early_return 被禁用\n\n如果使用了 JVMCI 编辑器（如 Graal），JVMTI 和  can_pop_frame 和 can_force_early_return 将被禁用。\n\n### linux 原生代码检查\n\n在 Linux 上启用了额外的保护措施，以防止本机代码中的缓冲区溢出。如果遇到缓冲区溢出，系统将写入消息“stack smashing detected”，程序将退出。\n\n### 添加了额外的 TeliaSonera 根证书\n\n下面的根证书添加到 openjdk 的信任证书库：\n\n```\nTeliaSonera\n   teliasonerarootcav1\n   DN: CN=TeliaSonera Root CA v1, O=TeliaSonera\n```\n\n### 不信任 Symantec Root CAs 锚定的 TLS 服务器证书\n\nJDK 将停止信任 Symantec 颁发的 TLS 服务器证书。与谷歌、Mozilla、苹果和微软最近宣布的类似计划一致。受影响的证书列表包括品牌为 GeoTrust、Thawte 和 VeriSign 的证书，这些证书由 Symantec 管理。\n',i=t("f373");Object(r["c"])(Object(i["a"])(a)).mount("#app")},19:function(e,n,t){e.exports=t("18fe")}});