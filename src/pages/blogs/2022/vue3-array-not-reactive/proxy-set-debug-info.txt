// 注释掉的代码都是调试过程中没有被执行的代码
function set(target, key, value, receiver) {
  // 代理 handler 的 set 方法参数说明：
  // target 原始对象，getItems() 返回的 list
  // key 属性名称，‘list’
  // value 要设置的值，onItemsChange 回调的 list 对象
  // receiver 最初被调用的对象,通常是 proxy 本身，这里就是 data.list， list的代理对象
  let oldValue = target[key];
  // 使用 shallowReactive 的情况下 shallow 标记是 true ，这里是 false
  if (!shallow && !isReadonly(value)) {
    value = toRaw(value);
    oldValue = toRaw(oldValue);
    // export const isArray = Array.isArray
    // !isArray(target) 返回 false
    if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
      // oldValue.value = value;
      // return true;
    }
  }
  const hadKey =
    isArray(target) && isIntegerKey(key) // isIntegerKey(key) 返回 false，下行不执行
      // ? Number(key) < target.length
      : hasOwn(target, key); // true
  // 使用反射设置值，相当于 data.list = list
  const result = Reflect.set(target, key, value, receiver);
  // don't trigger if target is something up in the prototype chain of original
  // 如果 target 是被代理的原始对象原型链上的某个对象就不触发
  // 实际上原始对象就是 target
  if (target === toRaw(receiver)) {
    if (!hadKey) {
      // 没有 key （'list'）属性，就触发 add
      // hadKey = true
      // trigger(target, "add" /* ADD */, key, value);
    } else if (hasChanged(value, oldValue)) {
      // hasChanged = (value: any, oldValue: any): boolean => !Object.is(value, oldValue)
      // value 和 oldValue 是同一个 list 数组对象, hasChanged 返回 false
      // trigger(target, "set" /* SET */, key, value, oldValue);
    }
  }
  return result;
}